{
  "expireTime": 9007200810434430000,
  "key": "transformer-remark-markdown-html-bd9ff2b0b11f391c05e28b8f5a74a944-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-reading-time-/reponame",
  "val": "<h3>Het verschil tussen beide.</h3>\n<p><strong>Vertex shader</strong></p>\n<blockquote>\n<p>De taak van een <strong>vertexshader</strong> is het berekenen van vertexposities. Op basis van de posities van de functie-uitgangen kan WebGL vervolgens verschillende soorten primitieven rasteren, inclusief punten, lijnen of driehoeken. Bij het rasteren van deze primitieven wordt een tweede functie geleverd door de user, namelijk de <strong>fragmentshader</strong>.</p>\n</blockquote>\n<p><strong>De structuur van de vertexshader zal er als volgt uitzien</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n gl_Position <span class=\"token operator\">=</span> doMathToMakeClipspaceCoordinates\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Vertex shaders moeten voorzien worden van data. Deze data kan verkregen worden op 3 manieren:</strong></p>\n<ol>\n<li>\n<p>Attributes: data afkomstig van buffers</p>\n</li>\n<li>\n<p>Textures: data van pixels/texels</p>\n</li>\n<li>\n<p>Uniforms: waarden die hetzelfde blijven voor elke pixel van een single drawcall</p>\n</li>\n</ol>\n<br>\n<p><strong>Fragment shader</strong></p>\n<blockquote>\n<p>De taak van een <strong>fragmentshader</strong> is om een ​​kleur te berekenen voor elke pixel van de primitieve die op dat moment wordt getekend.</p>\n</blockquote>\n<p><strong>De structuur van de fragmentshader zal er als volgt uitzien</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">precision mediump float<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n gl_FragColor <span class=\"token operator\">=</span> doMathToMakeAColor<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<p><strong>Ook fragment shaders moeten voorzien worden van data. Deze data kan verkregen worden op 3 manieren:</strong></p>\n<ol>\n<li>\n<p>Uniforms: waarden die hetzelfde blijven voor elke pixel van een single drawcall</p>\n</li>\n<li>\n<p>Textures: data van pixels/texels</p>\n</li>\n<li>\n<p>Varyings: gegeven afkomstig van de vertexshader en geïnterpoleerd</p>\n</li>\n</ol>"
}
